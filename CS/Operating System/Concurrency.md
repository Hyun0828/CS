# Concurrency

# 목차
- [Concurrency and Threads](#26-concurrency-and-threads)
  - [데이터 공유](#데이터-공유)
  - [원자성](#원자성)   

## 26. Concurrency and Threads

쓰레드는 프로세스에서의 하나의 실행 흐름이다. 쓰레드마다 PC와 연산을 위한 레지스터를 가지고 있다. 만약 2개의 쓰레드가 문맥 교환을 하는 상황이라면 실행 중인 쓰레드의 레지스터 내용을 PCB가 아닌 TCB에 저장하고 새로 실행될 쓰레드의 TCB에서 레지스터 값을 복원한다. 마치 프로세스의 문맥교환과 매우 흡사하다. 또한 쓰레드끼리 주소 공간을 공유하지만 스택은 따로 할당된다.

<img width="557" alt="스크린샷 2025-04-22 오후 10 14 35" src="https://github.com/user-attachments/assets/a00b0395-a980-43e4-bd6c-3a6eb89b35e9" />

스레드에서 매개변수, 리턴 값 같은 데이터는 스레드 고유의 스택 공간에 저장된다. 

이런 스레드들은 생성되면 즉시 실행될 수도 있고, 준비 상태에서 실행은 되지 않을 수도 있다. 만약 메인 스레드에서 2개의 스레드를 생성하고 특정 함수를 실행 시키고자 할 때, 스레드의 실행 순서와 함수 실행 순서 등은 정해지지 않고 매번 바뀐다. 

### 데이터 공유

스레드 실행 순서는 스케줄러의 동작에 따라 바뀔 수 있다. 만약 여러 스레드가 공유 데이터에 접근하면 어떻게 될까? 2개의 스레드가 전역 공유 변수를 갱신하는 코드를 살펴보자.

```c
#include <stdio.h>
#include <pthread.h>
#include "mythreads.h"

static volatile int counter = 0;

void *mythread(void *arg){
	// counter 값을 10,000,000번 +1 하는 로직
}

int main(int argc, char *argv[]){
	// 스레드 2개를 생성하고 각 스레드에서 mythread 함수 실행
}
```

우리는 counter 값이 20,000,000이 되기를 기대한다. 그러나 실제로는 이상한 값이 나온다.

counter에 1을 더하는 코드의 어셈블리 코드를 보면 다음과 같다.

```nasm
mov 0x8049a1c, %eax
add $0x1, %eax
mov %eax, 0x8049a1c
```

현재 counter 값이 50이라고 해보자. 스레드1이 mov, add까지 실행하고 인터럽트가 발생하면 스레드1의 레지스터 값들을 TCB에 저장하고 스레드2가 실행된다. 스레드2의 eax 레지스터에는 50이 저장된다. 스레드1에서 마지막 mov 명령어를 실행하지 않았기 때문이다. 스레드2에서 모든 명령어를 실행하고 counter 값이 51이 된 후 스레드1로 돌아온다고 하면 counter 값은 여전히 51이다.

이렇게 명령어의 실행 순서에 따라 결과가 달라지는 상황을 **race condition(경쟁 조건)** 이라고 한다. 멀티 프로세스나 멀티 스레드 환경에서 race condition이 발생하는 코드 부분을 **critical section(임계 구역)** 이라고 한다. 이러한 코드에서 필요한 것은 **mutual exclusion(상호 배제)** 이다. 상호 배제는 임계 구역에 하나의 스레드만 실행할 수 있게 보장해주는 것이다.

### 원자성

상호 배제 말고도 다양한 해결책들이 있다. 원자성을 보장하는 메소드를 이용하면 메소드 실행 중간에 인터럽트가 발생하지 않아 race condition이 발생하지 않는다. 상호 배제를 구현하기 위해서는 보통 동기화 함수들을 사용한다. 다른 방법으로 스레드가 잠들고 다른 스레드를 깨우는 **condition variable** 을 이용한 방법도 있다.
