# Virtualization

# 목차
- [Address Spaces](#13-address-spaces)
  - [초기 시스템](#초기-시스템) 
  - [멀티프로그래밍과 시분할](#멀티프로그래밍과-시분할) 
  - [주소 공간](#주소-공간) 
  - [목표](#목표)
- [Address Translation](#15-address-translation)
  - [동적 재배치](#동적-재배치)
  - [운영체제 이슈](#운영체제-이슈)
  - [정리](#정리)
- [Segmentation](#16-segmentation)
  - [세그멘테이션](#세그멘테이션)
  - [세그먼트의 종류](#세그먼트의-종류)
  - [스택](#스택)
  - [공유 지원](#공유-지원)
  - [소단위와 대단위](#소단위와-대단위)
  - [운영체제의 지원](#운영체제의-지원)
- [Free Space Management](#17-free-space-management)
  - [저수준 기법](#저수준-기법)
  - [빈 공간 할당 전략](#빈-공간-할당-전략)   

## 13. Address Spaces

### 초기 시스템

초기 컴퓨터는 많은 기능을 제공하지 않았다. 

![image](https://github.com/user-attachments/assets/0baeb71f-ba0f-4667-b4e9-50861b1f4630)

위 그림과 같이 물리 메모리에 하나의 프로세스만 존재했고 가상화는 거의 존재하지 않았다.

### 멀티프로그래밍과 시분할

시간이 지나면서 **멀티프로그래밍** 시대가 도래하였다. 운영체제는 여러 프로세스를 번갈아 가며 실행하였다. 한 프로세스가 입출력을 실행하면 CPU는 다른 프로세스로 전환하여 CPU의 이용률을 증가시켰다. 

곧 사람들은 **일괄처리방식** 컴퓨팅의 한계를 인식하고 즉시 응답을 받을 수 있는 대화식 이용 개념을 중요하게 생각하며 **시분할 컴퓨팅**의 시대가 시작되었다.

시분할을 구현하는 한 가지 방법은 하나의 프로세르를 짧은 시간 동안 실행시키는 것이다. 이후 프로세스를 중단하고 프로세스의 모든 상태를 디스크 종류의 장치에 저장하고 다른 프로세스의 상태를 탑재하여 실행시켰다. 그러나 이 방식은 레지스터 상태를 저장하고 복원하는 것에 문제는 없었지만 메모리의 내용 전체를 디스크에 저장하는 것에서 성능 상 문제가 발생했다. 

![image](https://github.com/user-attachments/assets/0ba1f673-76a8-4815-8a1c-7b348887bcef)

이런 시분할 시스템이 대중화되면서 각 **프로세스가 다른 프로세스를 접근하지 못하게 해야 하는 보호**가 중요한 문제로 대두되었다.

### 주소 공간

위와 같은 위험한 행위를 대비하기 위해 **주소 공간(Address Space)** 개념이 등장했다. 주소 공간은 실행 프로그램의 모든 메모리 상태를 갖는다. 명령어를 저장하는 **코드(code)** 와 함수 호출 체인 상의 현재 위치, 지역 변수, 함수 인자와 반환 값 등을 저장하는 **스택(stack)**, 동적으로 할당되는 메모리 공간인 **힙(heap)** 이 있다. 정적 변수를 저장하는 데이터 영역도 있다.

![image](https://github.com/user-attachments/assets/38c8c5b9-495f-44a6-a5e0-5e394463e0f5)

코드는 정적이기 때문에 주소 공간 상단에 배치하고 힙과 스택은 메모리가 확장되거나 축소될 수 있기 때문에 상단과 하단에 둔다. 힙은 아래 방향으로 확장하고 스택은 위 방향으로 확장하는데 이러한 배치는 관례일 뿐이다. **특히 멀티 쓰레드 환경에서는 이런 식으로 주소 공간을 나누면 동작하지 않는다.**

위의 그림처럼 실제로  프로그램이 물리 주소 0~16KB 사이에 존재하는 것은 아니다. 실제로는 임의의 물리 주소에 탑재된다. 그럼 그 물리 주소는 어떻게 알 수 있을까? 이 개념이 바로 메모리 가상화이다. 왜냐하면 프로그램은 자신이 특정 주소의 메모리에 탑재되고 큰 주소 공간을 가지고 있다고 생각하지만 현실은 그렇지 않기 때문이다.

### 목표

가상 메모리 시스템(VM)의 주요 목표는 다음과 같다.

- 투명성(transparency) : 운영체제는 실행 중인 프로그램이 가상 메모리의 존재를 인지하지 못하도록 구현해야 한다. 프로그램이 물리 메모리를 소유한 것처럼 행동하게 만들고 운영체제와 하드웨어가 모든 작업을 처리한다.
- 효율성(efficiency) : 시간적으로 너무 느려서는 안 되며 공간적으로는 너무 많은 메모리를 사용해선 안 된다.
- 보호(protection) : 운영체제는 서로 다른 프로세스끼리 영향을 주게 만들어선 안 되며 프로세스가 운영체제의 코드에 접근하게 만들어선 안 된다.

여담으로 예전에 c/c++ 수업에서 포인터를 이용해 변수의 주소를 출력해본 적이 있다. 이 때는 각 주소가 실제 메모리 주소 값 인줄 알았는데 사실 해당 주소는 가상 주소라고 한다. 이것이 바로 프로세스가 가상 메모리의 존재를 인지하지 못하게 하는 가상화 기술의 핵심이다.

## 15. Address Translation

가상 주소를 물리 주소로 바꾸는 주소 변환, 즉 메모리 가상화를 위한 첫 번째 시도를 살펴보자. 우선 사용자의 주소 공간은 물리 메모리에 연속적으로 배치되어야 한다고 가정한다. 또한 각 주소 공간의 크기는 같다고 가정한다. 물론 이후에는 이 가정을 완화하여 실제 메모리 가상화 기법을 배울 것이다.

프로그램 관점에서 주소 공간의 크기가 16KB라고 해보자. 프로그램의 모든 메모리 참조는 이 범위 내에 있어야 한다. 메모리 가상화를 위해서 운영체제는 프로세스를 물리 메모리 주소 0이 아닌 다른 곳에 위치시키고 싶다. 어떻게 프로세스 모르게 메모리를 다른 위치에 재배치 할 수 있을까?

### 동적 재배치

최초 시분할 컴퓨터에서는 베이스와 바운드라는 아이디어가 채택되었다. 이 기술은 동적 재배치라고 한다.

각 CPU마다 **base 레지스터** 와 **bound 레지스터** 가 존재한다. 베이스와 바운드 쌍은 우리가 원하는 위치에 주소 공간을 배치할 수 있게 한다. 배치와 동시에 프로세스가 오직 자신의 주소 공간에만 접근하는 것을 보장한다. 운영체제가 프로그램을 물리 메모리에 적재할 때 그 위치를 베이스 레지스터에 저장한다. 만약 프로세스가 물리주소 32KB에 저장된다면 베이스 레지스터에는 32KB가 저장된다.

```makefile
physical address = virtual address + base
```

위와 같이 주소 변환이 이루어진다.

예를 들어 PC 값이 128이고 베이스 레지스터 값이 32KB면 실제로 접근하는 물리주소는 32896이다. 만약 가상 주소 15KB의 값을 가져오라는 명령어를 실행하면 물리주소 47KB에 접근하는 것이다. 프로세스가 실행을 시작한 이후에도 주소 공간을 이동할 수 있기 때문에 동적 재배치라고 부른다.

바운드 레지스터는 프로세스 보호에 사용된다. 이 때 바운드 레지스터는 2가지 방식으로 정의될 수 있다.

- 바운드 레지스터에 주소 공간의 크기를 저장하고 접근하려는 가상 주소 값이 바운드 레지스터 값보다 크면 예외가 발생한다.
- 바운드 레지스터에 주소 공간의 마지막 물리 주소를 저장하고 실제로 변환한 물리 주소 값이 바운드 레지스터 값보다 크면 다른 프로세스를 접근하는 것이므로 예외가 발생한다.

### 운영체제 이슈

베이스, 바운드 방식의 가상 메모리 구현을 위해서 운영체제가 개입되어야 하는 시점들이 존재한다.

첫째, 프로세스가 생성될 때 운영체제는 주소 공간이 저장될 메모리 공간을 찾아야 한다. 다행히 주소 공간의 크기가 일정하고 물리 메모리를 슬롯의 배열로 보아 각 슬롯의 사용 여부를 관리한다. 운영체제는 새로운 프로세스를 할당할 공간을 찾기 위해 빈 리스트(free list)라는 자료구조를 검색한다.

둘째, 프로세스가 종료할 때 프로세스가 사용하던 메모리 공간을 빈 리스트에 넣고 정리한다.

셋째, 운영체제는 문맥 교환이 발생할 때 PCB에 베이스와 바운드 레지스터 값을 저장해야 한다. 마찬가지로 새로운 프로세스를 실행할 때 PCB에서 베이스와 바운드 레지스터 값을 로드해야 한다.

운영체제가 주소 공간의 위치를 쉽게 옮길 수 있는데 프로세스의 실행을 중지시키고 새 위치로 주소 공간을 복사한다. 그리고 베이스 레지스터 값을 갱신하여 새 위치를 가리키게 한다.

넷째, 운영체제는 부팅할 때 예외 핸들러 또는 호출될 함수를 제공해야 한다. 예를 들어, 프로세스가 바운드 레지스터 값 밖의 메모리 공간에 접근하려는 경우 CPU는 예외를 발생시킨다. 운영체제는 이러한 예외가 발생할 때 조치를 취할 준비가 되어 있어야 한다.

### 정리

동적 재배치 방식은 베이스 레지스터를 가상 주소에 더하고 생성된 주소가 바운드 레지스터를 벗어나는지 검사하는 하드웨어 회로만 추가하면 되기 때문에 간단하고 매우 효율적이다. 또한 프로세스 보호 기능도 제공한다. 그러나 동적 재배치는 비효율적이기도 하다. 

<img src="https://github.com/user-attachments/assets/457bc4b9-b553-4ffb-8588-ae6d92de9dfb" width="200"/>

위와 같이 32KB에서 42KB의 물리 메모리를 사용할 때, 스택과 힙이 크지 않아 둘 사이의 공간이 낭비되는데 이를 내부 단편화라고 한다. 고정 크기 슬롯에 주소 공간을 배치해야 하기 때문에 내부 단편화를 필연적이다. 이를 방지하기 위해 더 정교한 기법이 필요하다. 그러한 기법을 세그멘테이션이라고 부른다.

## 16. Segmentation

동적 재배치 방식의 문제점은 메모리 낭비가 심하다는 것이다. 모든 주소 공간을 메모리에 적재하다 보니 힙과 스택 사이에 사용하지 않는 공간처럼 메모리 낭비가 발생하게 된다. 그래서 이 문제를 해결하기 위해 **세그멘테이션(segmentation)** 기법이 등장했다.

### 세그멘테이션

기존에는 주소 공간마다 베이스와 바운드 레지스터가 존재했다. 특정 길이를 가지는 연속적인 주소 공간인 세그먼트마다 베이스와 바운드 쌍을 두고 각 세그먼트를 물리 메모리의 각기 다른 위치에 배치할 수 있으며 사용되지 않는 세그먼트는 물리 메모리에 올리지 않아 메모리 낭비를 방지할 수 있다.

<img src="https://github.com/user-attachments/assets/b0b8ce7e-cb57-49d1-987b-c1cc23b00d72" height="400" width="200"/>
<img src="https://github.com/user-attachments/assets/90bdee0b-549d-4a07-a32b-dcf535b00679" width="200"/>

스택, 코드, 힙 3개의 세그먼트를 독립적으로 배치한다. 

가상 주소 100번지를 참조한다고 하자. 100번지는 주소 공간에서 코드 세그먼트에 속한다. 코드 세그먼트의 베이스 값에 100번지를 더해 32KB+100이 물리 주소가 된다. 이 때 바운드 레지스터는 각 세그먼트의 크기를 저장한다. 100번지인 offset이 바운드보다 작으면 된다.

만약 4200번지를 참조한다고 해보자. 4200번지는 힙 세그먼트에 속한다. 물리 주소를 계산할 때 주의할 점은 4200번지에 34KB를 더하는 것이 아니라 힙 안에서의 offset을 더해주어야 한다. offset은 4200-4KB이므로 104이다. 물리 주소는 104 + 34KB가 된다.

만약 힙을 벗어나 7KB번지를 참조한다고 하자. 하드웨어가 그 주소가 범위를 벗어났다는 것을 감지하고 **Segmentation Fault** 를 발생시킨다.

### 세그먼트의 종류

하드웨어는 가상 주소가 어느 세그먼트를 참조하는 지 어떻게 알 수 있을까? 가상 주소의 최상위 몇 비트를 기준으로 세그먼트를 구분한다. 예를 들어 힙, 스택, 코드 3개의 세그먼트를 구분하기 위해서 최상위 2비트를 세그먼트 구분에 사용한다.

<img src="https://github.com/user-attachments/assets/1384e8d3-5705-45a2-87cc-b307156f2bdd" width="250"/>

<img src="https://github.com/user-attachments/assets/eba3663f-b387-4218-b255-e790f6524284" width="250"/>

00이면 코드, 01이면 힙, 10이면 스택 등으로 구분한다. 예를 들어 4200번지를 변환해보자.

4200번지는 위와 같은데 세그먼트 비트가 01이니 힙 영역이고 오프셋은 나머지 12비트인 104이다. 오프셋 값이 바운드보다 작은 지 여부도 추가로 검사해주면 된다. 그런데 최상위 2비트를 사용하면 지정 가능한 하나의 세그먼트는 미사용으로 남아 전체 주소 공간의 1/4은 사용이 불가능하다. 이 문제를 위해 힙과 코드를 하나의 세그먼트로 합치고 최상위 1비트만 사용하는 경우도 있다.

### 스택

스택은 다른 세그먼트와 달리 반대 방향으로 확장된다. 따라서 다른 방식의 변환이 필요하다. 이를 위해 하드웨어는 세그먼트가 어느 방향으로 확장하는 지에 대한 비트를 저장한다. 1이면 주소가 커지는 쪽으로, 0이면 주소가 작아지는 쪽으로 확장한다. 

<img src="https://github.com/user-attachments/assets/433168c8-e6f1-4061-9603-a431110f1495" width="300"/>

예를 들어 가상 주소 15KB에 접근한다고 하자. 15KB는 11 1100 0000 0000 이므로 상위 2비트를 제외하면 3KB의 오프셋이 남는다. 다른 세그먼트는 이 오프셋을 그대로 활용하지만 스택은 오프셋에서 세그먼트 크기를 뺀 -1KB를 오프셋으로 사용한다. 따라서 물리 주소는 베이스 28KB - 1KB = 27KB가 된다.

### 공유 지원

메모리를 절약하기 위해 주소 공간들 간에 특정 세그먼트를 공유하기도 하는데 **코드 공유가 일반적이다.**

공유를 지원하기 위해 **protection bit** 추가가 필요하다. 세그먼트를 읽을 수 있는지 쓸 수 있는지를 결정하는 비트이다. 코드 세그먼트를 읽기 전용으로 설정하면 주소 공간의 독립성을 유지하면서도 여러 프로세스가 주소 공간을 일부 공유할 수 있다. 

<img src="https://github.com/user-attachments/assets/c7ee49f2-4851-464b-8e28-bedf8297e9a5" width="350"/>

### 소단위와 대단위

지금까지 코드, 스택, 힙 같은 소수의 세그먼트만 지원하는 시스템만 보았다. 비교적 큰 단위의 공간으로 분할하는 **대단위(coarse-grained)** 라고 한다. 더 작은 크기의 공간으로 나누는 것을 **소단위(fined-grained)** 세그멘테이션이라고 부른다. 많은 수의 세그먼트를 지원하기 위해 세그먼트 테이블을 이용해 손쉽게 생성하고 융통성 있게 관리할 수 있다.

### 운영체제의 지원

세그먼트를 독립적으로 물리 메모리에 배치하기 때문에 물리 메모리를 엄청나게 절약할 수 있다. 그러나 세그멘테이션도 많은 문제를 제기한다.

- 문맥 교환시 세그먼트 레지스터의 저장과 복원 과정이 추가로 필요하다.
- 미사용 중인 물리 메모리 공간의 관리가 필요하다.
- 가장 큰 문제는 **외부 단편화(external fragmentation)** 로 인한 메모리 낭비다.

    <img src="https://github.com/user-attachments/assets/4da3295f-6ec3-4484-8ff8-c0fdb77b2c09" width="400"/>

세그먼트의 크기가 달라 위와 같은 상황이 발생한다. 분명 빈 공간의 총합은 크지만 새로운 세그먼트를 물리 메모리에 배치하지 못한다. 이 문제의 해결책 중 하나로 **압축** 이 있다. 그러나 압축은 비용이 많이 드는 문제가 있다. 

다른 간단한 방법은 빈 공간 리스트를 관리하는 알고리즘을 사용하는 것인데 최적 적합(best-fit), 최악 적합(worst-fit), 최초 적합(first-fit) 및 버디 알고리즘(buddy algorithm) 등을 포함해 수백 개의 방식이 존재한다. **그러나 알고리즘이 아무리 정교하게 동작해도 세그멘테이션에선 외부 단편화를 막을 수 없다.**

## 17. Free Space Management

페이징 개념을 사용하기 전에 세그멘테이션으로 물리 메모리를 관리할 때 빈 공간 관리는 어려운 문제다. 빈 공간 관리를 효율적으로 하는 방법들에 대해 알아보자.

void malloc(size_t size)와 void free(void *ptr)과 같은 기본 인터페이스를 가정한다. 이 라이브러리가 관리하는 공간인 힙의 빈 공간을 관리하는 데는 일반적으로 연결리스트가 사용된다. 물론 반드시 리스트일 필요는 없다.

### 저수준 기법

우선 대부분의 할당기에서 사용하는 분할과 병합에 대해 알아보자. 두 번째로 할당된 영역의 크기를 빠르고 상대적으로 쉽게 파악할 수 있는 방법을, 마지막으로 빈 공간과 사용 중인 공간을 추적하기 위해 간단한 리스트를 구현하는 방법을 살펴보자.

1. **분할과 병합**
    
    빈 공간 리스트는 힙에 있는 빈 공간들의 집합이다.
   
    <img width="302" alt="image" src="https://github.com/user-attachments/assets/60da3c42-d401-4c44-ab4f-0e05965c59e0" />
    <img width="374" alt="image" src="https://github.com/user-attachments/assets/704a2272-5407-4ad1-bf20-88d913b7daab" />
    
    위와 같이 10바이트짜리 빈 공간이 2개 있다고 가정하면 빈 공간 리스트는 위와 같다. 이런 상황에선 외부 단편화 문제로 인해 10바이트를 초과하는 모든 요청은 NULL을 반환할 것이다. 그럼 10바이트보다 작은 요청은 어떻게 처리할까?
    
    1바이트 요청이 발생했다고 하면 **분할**이 수행된다. 할당기가 리스트의 두 번째 원소를 사용해 빈 공간을 할당해주었다고 하면 아래와 같이 변한다.
   
    <img width="360" alt="image (2)" src="https://github.com/user-attachments/assets/78be6515-d4bd-421a-a3b8-3a741dec7dd8" />
    
    만약 free(10)을 통해 메모리를 반환하게 되면 리스트는 어떻게 변할까? 단순히 노드를 추가해보자..
    <img width="489" alt="image (3)" src="https://github.com/user-attachments/assets/90288d8f-f8dc-486d-b354-ea9c1eb91407" />
    
    여기서 외부 단편화 문제가 발생한다. 빈 공간의 총합은 30바이트 이지만 10바이트를 초과하는 요청에 대해서는 메모리 할당이 불가능해진다. 그래서 **메모리 청크의 주소와 인접한 빈 청크를 병합하는 과정**을 거친다.

    <img width="241" alt="image (4)" src="https://github.com/user-attachments/assets/ac682062-5c94-4c29-8254-170afb129a87" />
    
3. **할당된 공간의 크기 파악**
    
    free 메소드는 메모리 영역의 주소만 인자로 넘겨줄 뿐, 해제되는 메모리 영역의 크기는 모른다. 이 정보를 어떻게 알 수 있을까?
    
    이 작업을 위해 대부분의 할당기는 **메모리 앞에 헤더 블럭에 추가 정보를 저장한다.**
   
    <img width="478" alt="image (5)" src="https://github.com/user-attachments/assets/198a7b6e-b084-497a-a674-ed387fc66b7a" />
    
    ptr = malloc(20);을 호출해도 20바이트 메모리 공간 앞에 기타 정보를 저장한다. 이 때 magic 값은 부가적인 무결성 검사를 제공하기 위한 매직 넘버이다.
    
    헤더 공간의 추가적인 할당을 위해 사용자가 N 바이트를 요청해도 사실은 N + 헤더 크기 만큼의 청크를 빈 공간 리스트에서 탐색하게 된다.
    
5. **빈 공간 리스트 내장**
    
    이러한 빈 공간 리스트를 빈 공간에 어떻게 구현할 수 있을까?

    <img width="515" alt="image (6)" src="https://github.com/user-attachments/assets/0274dc1c-44eb-46b6-952c-3336833470bd" />
    
    힙의 크기가 4KB라고 가정하자. 첫 빈 공간 리스트는 위와 같이 생성된다. 여기서 만약 100 바이트 공간 할당 요청이 발생했다고 하면 어떻게 될까? 헤더 크기를 8바이트라고 가정하면 108바이트 공간이 청크에서 분할된다. 4088 - 108 = 3980 바이트의 빈 공간 청크가 남는다.

    <img width="513" alt="image (7)" src="https://github.com/user-attachments/assets/da539f7d-8db7-46fe-9d13-eec5ec75c5cb" />
    
     만약 100바이트씩 할당된 공간이 3개라고 해보자. (2번의 추가적인 요청)

    <img width="518" alt="image (8)" src="https://github.com/user-attachments/assets/b61a0fea-fb4c-4a5f-b291-5b9a34f27686" />
    
    위 상황에서 free(16500)을 호출하면 어떻게 될까? 16500은 16384 + 108 + 8로 위 그림에서 sptr의 위치와 같다.
   
    <img width="530" alt="스크린샷 2025-04-20 오후 12 41 18" src="https://github.com/user-attachments/assets/48f93597-5cfd-45f1-bfc8-22a2c98efe89" />

    간단하다. 헤더의 내용만 size와 다음 빈 공간 청크를 가리키는 next 주소값으로 변경된다. 나머지 공간들도 해제된다면 같은 방식으로 빈 공간 리스트가 형성되지만 청크들이 단편화되어 있는 문제가 있다. 이는 인접 청크끼리 병합하여 해결할 수 있다.
    
7. **힙의 확장**
    
    만약 힙 전체 공간이 부족하면 어떻게 해야 할까? 가장 쉬운 방법은 실패를 반환하는, 즉 NULL 값을 반환하는 것이다. 물론 이 방법도 좋긴 하지만 특정 시스템 콜 (UNIX에서는 sbrk)을 통해 빈 물리 공간에서 새로운 청크를 할당 받을 수 있다. 
    

### 빈 공간 할당 전략

빈 공간 리스트가 어떻게 생겼는지 알았으니 요청이 발생했을 때 어떤 청크가 할당 되어야 할 지를 알아보자. 결국 이상적인 할당기는 빠르고 단편화를 최소로 만들어야 한다. 

1. **최적 적합 (Best Fit)**
    
    빈 공간 리스트를 검색하여 요청한 크기와 같거나 더 큰 메모리 청크 중 가장 작은 크기의 청크를 반환한다. 매우 간단하지만 Worst-Case에서 모든 청크를 탐색해야 한다.
    
2. 최악 적합 (Worst Fit)
    
    가장 큰 빈 청크를 찾아 분할하게 되는데 이 역시 빈 공간 전체를 탐색해야 하기 때문에, 또한 단편화가 많이 발생하는 문제가 있다.
    
3. **최초 적합 (First Fit)**
    
    간단하게 요청보다 큰 첫 블럭을 찾아서 요청만큼 반환한다. 속도가 빠르긴 하지만 리스트의 시작 부분에 단편화된 작은 청크들이 많이 몰리게 된다. 따라서 빈 공간 리스트를 주소-기반 정렬시켜 어느정도 해소할 수 있다.
    
4. **다음 적합 (Next Fit)**
    
    최초 적합과 달리 첫 탐색 이후의 탐색에 대해서 이전 탐색에서 찾았던 청크 이후부터 탐색하여 리스트의 첫 부분에만 단편이 집중적으로 발생하는 문제를 해소한다. 성능은 최초 적합과 비슷하다.
    

간단하게 예를 들어 보자.

빈 공간 리스트가 “10 → 30 → 20” 이라고 해보자. 그리고 15바이트 요청이 발생했다고 하면

- 최적 적합 : 10 → 30 → 5
- 최악 적합 : 10 → 15 → 20
- 최초 적합 : 10 → 15 → 20
- 다음 적합 : 10 → 15 → 20

이 기본적인 접근 방식 외에도 다른 방법들도 있다. 

1. **개별 리스트(Segregated List)**
    
    특정 응용 프로그램이 한두 개 자주 요청하는 크기가 있다면, 그 크기의 객체를 관리하기 위한 별도의 리스트를 유지한다. 예를 들어 2KB 요청이 자주 발생한다면 2KB 크기들의 메모리 청크를 따로 관리하여 할당과 해제 요청을 신속하게 처리하는 것이다. 이 문제는 특정 메모리 풀과 일반 메모리 풀의 메모리 할당 비율 문제가 있다.
    
2. **슬랩 할당기(Slab Allocator)**
    
    커널이 부팅될 때, 커널 객체를 위한 여러 객체 캐시를 할당한다. 커널 객체란 락, 아이노드 등 자주 요청되는 자료 구조이며 객체 캐시는 지정된 크기의 객체들로 구성된 빈 공간 리스트이다. 개별 리스트 방식에 비해 사전에 빈 객체들을 초기화된 상태로 유지하기 때문에 성능이 더 우수하다.
    
3. **버디 할당(Buddy Allocator)**

    <img width="309" alt="image (9)" src="https://github.com/user-attachments/assets/ea5141bf-3e01-452c-8df3-415cdf27f6e2" />
    
    빈 메모리는 개념적으로 2^N인 하나의 큰 공간으로 생각된다. 메모리 요청이 발생하면 요청을 충족시키기에 충분한 공간이 생길 때까지 빈 공간을 2개로 분할한다. 예를 들어 7KB 요청이 발생하면 8KB가 등장할 때까지 2개씩 분할한다. 메모리 크기가 2의 거듭제곱 형태이기 때문에 내부 단편화 문제가 빈번하게 발생한다. 그러나 블럭이 해제될 때, 블럭끼리 합병하는 과정이 쉬우며 트리를 따라 합병이 가능할 때까지 계속 진행된다.
