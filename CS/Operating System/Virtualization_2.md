# Virtualization

# 목차
- [Address Spaces](#13-address-spaces)
  - [초기 시스템](#초기-시스템) 
  - [멀티프로그래밍과 시분할](#멀티프로그래밍과-시분할) 
  - [주소 공간](#주소-공간) 
  - [목표](#목표)
- [Address Translation](#15-address-translation)
  - [동적 재배치](#동적-재배치)
  - [운영체제 이슈](#운영체제-이슈)
  - [정리](#정리)

## 13. Address Spaces

### 초기 시스템

초기 컴퓨터는 많은 기능을 제공하지 않았다. 

![image](https://github.com/user-attachments/assets/0baeb71f-ba0f-4667-b4e9-50861b1f4630)

위 그림과 같이 물리 메모리에 하나의 프로세스만 존재했고 가상화는 거의 존재하지 않았다.

### 멀티프로그래밍과 시분할

시간이 지나면서 **멀티프로그래밍** 시대가 도래하였다. 운영체제는 여러 프로세스를 번갈아 가며 실행하였다. 한 프로세스가 입출력을 실행하면 CPU는 다른 프로세스로 전환하여 CPU의 이용률을 증가시켰다. 

곧 사람들은 **일괄처리방식** 컴퓨팅의 한계를 인식하고 즉시 응답을 받을 수 있는 대화식 이용 개념을 중요하게 생각하며 **시분할 컴퓨팅**의 시대가 시작되었다.

시분할을 구현하는 한 가지 방법은 하나의 프로세르를 짧은 시간 동안 실행시키는 것이다. 이후 프로세스를 중단하고 프로세스의 모든 상태를 디스크 종류의 장치에 저장하고 다른 프로세스의 상태를 탑재하여 실행시켰다. 그러나 이 방식은 레지스터 상태를 저장하고 복원하는 것에 문제는 없었지만 메모리의 내용 전체를 디스크에 저장하는 것에서 성능 상 문제가 발생했다. 

![image](https://github.com/user-attachments/assets/0ba1f673-76a8-4815-8a1c-7b348887bcef)

이런 시분할 시스템이 대중화되면서 각 **프로세스가 다른 프로세스를 접근하지 못하게 해야 하는 보호**가 중요한 문제로 대두되었다.

### 주소 공간

위와 같은 위험한 행위를 대비하기 위해 **주소 공간(Address Space)** 개념이 등장했다. 주소 공간은 실행 프로그램의 모든 메모리 상태를 갖는다. 명령어를 저장하는 **코드(code)** 와 함수 호출 체인 상의 현재 위치, 지역 변수, 함수 인자와 반환 값 등을 저장하는 **스택(stack)**, 동적으로 할당되는 메모리 공간인 **힙(heap)** 이 있다. 정적 변수를 저장하는 데이터 영역도 있다.

![image](https://github.com/user-attachments/assets/38c8c5b9-495f-44a6-a5e0-5e394463e0f5)

코드는 정적이기 때문에 주소 공간 상단에 배치하고 힙과 스택은 메모리가 확장되거나 축소될 수 있기 때문에 상단과 하단에 둔다. 힙은 아래 방향으로 확장하고 스택은 위 방향으로 확장하는데 이러한 배치는 관례일 뿐이다. **특히 멀티 쓰레드 환경에서는 이런 식으로 주소 공간을 나누면 동작하지 않는다.**

위의 그림처럼 실제로  프로그램이 물리 주소 0~16KB 사이에 존재하는 것은 아니다. 실제로는 임의의 물리 주소에 탑재된다. 그럼 그 물리 주소는 어떻게 알 수 있을까? 이 개념이 바로 메모리 가상화이다. 왜냐하면 프로그램은 자신이 특정 주소의 메모리에 탑재되고 큰 주소 공간을 가지고 있다고 생각하지만 현실은 그렇지 않기 때문이다.

### 목표

가상 메모리 시스템(VM)의 주요 목표는 다음과 같다.

- 투명성(transparency) : 운영체제는 실행 중인 프로그램이 가상 메모리의 존재를 인지하지 못하도록 구현해야 한다. 프로그램이 물리 메모리를 소유한 것처럼 행동하게 만들고 운영체제와 하드웨어가 모든 작업을 처리한다.
- 효율성(efficiency) : 시간적으로 너무 느려서는 안 되며 공간적으로는 너무 많은 메모리를 사용해선 안 된다.
- 보호(protection) : 운영체제는 서로 다른 프로세스끼리 영향을 주게 만들어선 안 되며 프로세스가 운영체제의 코드에 접근하게 만들어선 안 된다.

여담으로 예전에 c/c++ 수업에서 포인터를 이용해 변수의 주소를 출력해본 적이 있다. 이 때는 각 주소가 실제 메모리 주소 값 인줄 알았는데 사실 해당 주소는 가상 주소라고 한다. 이것이 바로 프로세스가 가상 메모리의 존재를 인지하지 못하게 하는 가상화 기술의 핵심이다.

## 15. Address Translation

가상 주소를 물리 주소로 바꾸는 주소 변환, 즉 메모리 가상화를 위한 첫 번째 시도를 살펴보자. 우선 사용자의 주소 공간은 물리 메모리에 연속적으로 배치되어야 한다고 가정한다. 또한 각 주소 공간의 크기는 같다고 가정한다. 물론 이후에는 이 가정을 완화하여 실제 메모리 가상화 기법을 배울 것이다.

프로그램 관점에서 주소 공간의 크기가 16KB라고 해보자. 프로그램의 모든 메모리 참조는 이 범위 내에 있어야 한다. 메모리 가상화를 위해서 운영체제는 프로세스를 물리 메모리 주소 0이 아닌 다른 곳에 위치시키고 싶다. 어떻게 프로세스 모르게 메모리를 다른 위치에 재배치 할 수 있을까?

### 동적 재배치

최초 시분할 컴퓨터에서는 베이스와 바운드라는 아이디어가 채택되었다. 이 기술은 동적 재배치라고 한다.

각 CPU마다 **base 레지스터** 와 **bound 레지스터** 가 존재한다. 베이스와 바운드 쌍은 우리가 원하는 위치에 주소 공간을 배치할 수 있게 한다. 배치와 동시에 프로세스가 오직 자신의 주소 공간에만 접근하는 것을 보장한다. 운영체제가 프로그램을 물리 메모리에 적재할 때 그 위치를 베이스 레지스터에 저장한다. 만약 프로세스가 물리주소 32KB에 저장된다면 베이스 레지스터에는 32KB가 저장된다.

```makefile
physical address = virtual address + base
```

위와 같이 주소 변환이 이루어진다.

예를 들어 PC 값이 128이고 베이스 레지스터 값이 32KB면 실제로 접근하는 물리주소는 32896이다. 만약 가상 주소 15KB의 값을 가져오라는 명령어를 실행하면 물리주소 47KB에 접근하는 것이다. 프로세스가 실행을 시작한 이후에도 주소 공간을 이동할 수 있기 때문에 동적 재배치라고 부른다.

바운드 레지스터는 프로세스 보호에 사용된다. 이 때 바운드 레지스터는 2가지 방식으로 정의될 수 있다.

- 바운드 레지스터에 주소 공간의 크기를 저장하고 접근하려는 가상 주소 값이 바운드 레지스터 값보다 크면 예외가 발생한다.
- 바운드 레지스터에 주소 공간의 마지막 물리 주소를 저장하고 실제로 변환한 물리 주소 값이 바운드 레지스터 값보다 크면 다른 프로세스를 접근하는 것이므로 예외가 발생한다.

### 운영체제 이슈

베이스, 바운드 방식의 가상 메모리 구현을 위해서 운영체제가 개입되어야 하는 시점들이 존재한다.

첫째, 프로세스가 생성될 때 운영체제는 주소 공간이 저장될 메모리 공간을 찾아야 한다. 다행히 주소 공간의 크기가 일정하고 물리 메모리를 슬롯의 배열로 보아 각 슬롯의 사용 여부를 관리한다. 운영체제는 새로운 프로세스를 할당할 공간을 찾기 위해 빈 리스트(free list)라는 자료구조를 검색한다.

둘째, 프로세스가 종료할 때 프로세스가 사용하던 메모리 공간을 빈 리스트에 넣고 정리한다.

셋째, 운영체제는 문맥 교환이 발생할 때 PCB에 베이스와 바운드 레지스터 값을 저장해야 한다. 마찬가지로 새로운 프로세스를 실행할 때 PCB에서 베이스와 바운드 레지스터 값을 로드해야 한다.

운영체제가 주소 공간의 위치를 쉽게 옮길 수 있는데 프로세스의 실행을 중지시키고 새 위치로 주소 공간을 복사한다. 그리고 베이스 레지스터 값을 갱신하여 새 위치를 가리키게 한다.

넷째, 운영체제는 부팅할 때 예외 핸들러 또는 호출될 함수를 제공해야 한다. 예를 들어, 프로세스가 바운드 레지스터 값 밖의 메모리 공간에 접근하려는 경우 CPU는 예외를 발생시킨다. 운영체제는 이러한 예외가 발생할 때 조치를 취할 준비가 되어 있어야 한다.

### 정리

동적 재배치 방식은 베이스 레지스터를 가상 주소에 더하고 생성된 주소가 바운드 레지스터를 벗어나는지 검사하는 하드웨어 회로만 추가하면 되기 때문에 간단하고 매우 효율적이다. 또한 프로세스 보호 기능도 제공한다. 그러나 동적 재배치는 비효율적이기도 하다. 

<img src="https://github.com/user-attachments/assets/457bc4b9-b553-4ffb-8588-ae6d92de9dfb" width="200"/>

위와 같이 32KB에서 42KB의 물리 메모리를 사용할 때, 스택과 힙이 크지 않아 둘 사이의 공간이 낭비되는데 이를 내부 단편화라고 한다. 고정 크기 슬롯에 주소 공간을 배치해야 하기 때문에 내부 단편화를 필연적이다. 이를 방지하기 위해 더 정교한 기법이 필요하다. 그러한 기법을 세그멘테이션이라고 부른다.
