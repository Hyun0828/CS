# Virtualization

# 목차
- [Address Spaces](#13-address-spaces)
  -[초기 시스템](#초기-시스템)
  -[멀티프로그래밍과 시분할](#멀티프로그래밍과-시분할)
  -[주소 공간](#주소-공간)
  -[목표](#목표)

## 13. Address Spaces

### 초기 시스템

초기 컴퓨터는 많은 기능을 제공하지 않았다. 

![image](https://github.com/user-attachments/assets/0baeb71f-ba0f-4667-b4e9-50861b1f4630)

위 그림과 같이 물리 메모리에 하나의 프로세스만 존재했고 가상화는 거의 존재하지 않았다.

### 멀티프로그래밍과 시분할

시간이 지나면서 **멀티프로그래밍** 시대가 도래하였다. 운영체제는 여러 프로세스를 번갈아 가며 실행하였다. 한 프로세스가 입출력을 실행하면 CPU는 다른 프로세스로 전환하여 CPU의 이용률을 증가시켰다. 

곧 사람들은 **일괄처리방식** 컴퓨팅의 한계를 인식하고 즉시 응답을 받을 수 있는 대화식 이용 개념을 중요하게 생각하며 **시분할 컴퓨팅**의 시대가 시작되었다.

시분할을 구현하는 한 가지 방법은 하나의 프로세르를 짧은 시간 동안 실행시키는 것이다. 이후 프로세스를 중단하고 프로세스의 모든 상태를 디스크 종류의 장치에 저장하고 다른 프로세스의 상태를 탑재하여 실행시켰다. 그러나 이 방식은 레지스터 상태를 저장하고 복원하는 것에 문제는 없었지만 메모리의 내용 전체를 디스크에 저장하는 것에서 성능 상 문제가 발생했다. 

![image](https://github.com/user-attachments/assets/0ba1f673-76a8-4815-8a1c-7b348887bcef)

이런 시분할 시스템이 대중화되면서 각 **프로세스가 다른 프로세스를 접근하지 못하게 해야 하는 보호**가 중요한 문제로 대두되었다.

### 주소 공간

위와 같은 위험한 행위를 대비하기 위해 **주소 공간(Address Space)** 개념이 등장했다. 주소 공간은 실행 프로그램의 모든 메모리 상태를 갖는다. 명령어를 저장하는 **코드(code)** 와 함수 호출 체인 상의 현재 위치, 지역 변수, 함수 인자와 반환 값 등을 저장하는 **스택(stack)**, 동적으로 할당되는 메모리 공간인 **힙(heap)** 이 있다. 정적 변수를 저장하는 데이터 영역도 있다.

![image](https://github.com/user-attachments/assets/38c8c5b9-495f-44a6-a5e0-5e394463e0f5)

코드는 정적이기 때문에 주소 공간 상단에 배치하고 힙과 스택은 메모리가 확장되거나 축소될 수 있기 때문에 상단과 하단에 둔다. 힙은 아래 방향으로 확장하고 스택은 위 방향으로 확장하는데 이러한 배치는 관례일 뿐이다. **특히 멀티 쓰레드 환경에서는 이런 식으로 주소 공간을 나누면 동작하지 않는다.**

위의 그림처럼 실제로  프로그램이 물리 주소 0~16KB 사이에 존재하는 것은 아니다. 실제로는 임의의 물리 주소에 탑재된다. 그럼 그 물리 주소는 어떻게 알 수 있을까? 이 개념이 바로 메모리 가상화이다. 왜냐하면 프로그램은 자신이 특정 주소의 메모리에 탑재되고 큰 주소 공간을 가지고 있다고 생각하지만 현실은 그렇지 않기 때문이다.

### 목표

가상 메모리 시스템(VM)의 주요 목표는 다음과 같다.

- 투명성(transparency) : 운영체제는 실행 중인 프로그램이 가상 메모리의 존재를 인지하지 못하도록 구현해야 한다. 프로그램이 물리 메모리를 소유한 것처럼 행동하게 만들고 운영체제와 하드웨어가 모든 작업을 처리한다.
- 효율성(efficiency) : 시간적으로 너무 느려서는 안 되며 공간적으로는 너무 많은 메모리를 사용해선 안 된다.
- 보호(protection) : 운영체제는 서로 다른 프로세스끼리 영향을 주게 만들어선 안 되며 프로세스가 운영체제의 코드에 접근하게 만들어선 안 된다.

여담으로 예전에 c/c++ 수업에서 포인터를 이용해 변수의 주소를 출력해본 적이 있다. 이 때는 각 주소가 실제 메모리 주소 값 인줄 알았는데 사실 해당 주소는 가상 주소라고 한다. 이것이 바로 프로세스가 가상 메모리의 존재를 인지하지 못하게 하는 가상화 기술의 핵심이다.
