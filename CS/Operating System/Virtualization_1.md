# Virtualization_1

# 목차
- [Processes](#processes)
- [Limited Direct Execution](#limited-direct-execution)
  - [제한된 연산](#제한된-연산)
  - [프로세스 간 전환](#프로세스-간-전환)
- [Scheduling](#scheduling)
  - [선입선출(First In First Out)](#선입선출first-in-first-out)
  - [최단 작업 우선(Shortest Job First, SJF)](#최단-작업-우선shortest-job-first-sjf)
  - [최단 잔여시간 우선 (Shortest Time-to-Completion First, STCF or PSJF)](#최단-잔여시간-우선-shortest-time-to-completion-first-stcf-or-psjf)
  - [응답 시간](#응답-시간)
  - [라운드 로빈(Round-Robin, RR)](#라운드-로빈round-robin-rr)
  - [입출력을 고려한 스케줄링](#입출력을-고려한-스케줄링)
- [Multi-level Feedback Queue](#multi-level-feedback-queue)
  - [MLFQ](#mlfq)
  - [MLFQ 조정](#mlfq-조정)
  - [MLFQ 요약](#mlfq-요약)


## 4. Processes

일반적으로 프로세스는 실행 중인 프로그램으로 정의한다. 프로세스의 구성 요소를 이해하기 위해서는 하드웨어 상태(machine state)를 이해해야 한다. 

하드웨어 상태 중 가장 중요한 구성 요소는 메모리이다. 모든 명령어와 데이터는 메모리(주소 공간(Address Space))에 저장된다. 프로세스가 접근할 수 있는 메모리는 프로세스를 구성하는 요소이다.

레지스터도 프로세스의 하드웨어 상태를 구성하는 요소 중 하나 인데 어느 명령어 실행 중 인지를 알려주는 프로그램 카운터(PC), 함수의 변수와 리턴 주소를 저장하는 스택을 관리하는 스택 포인터(SP)와 프레임 포인터(FP)가 있다.

## 6. Limited Direct Execution

### 제한된 연산

운영체제 개발자들은 프로그램을 빠르게 실행하기 위하여 프로그램을 CPU 상에서 직접 실행하고자 했다. 만일 프로세스가 디스크 입출력 요청이나 시스템 자원에 대한 추가 할당 같은 연산을 수행하길 원한다면 어떻게 될까? 그대로 동작하게 만들 수도 있지만 이는 바람직한 시스템 구축과는 거리가 멀다. 그래서 하드웨어는 2가지 실행 모드를 제공하여 운영체제를 돕는다. 

**사용자 모드(user mode)** 에서 응용 프로그램은 하드웨어 자원에 대한 접근 권한이 일부 제한되어 있다. 반면 **커널 모드(kernel mode)** 에서 운영체제는 모든 자원에 대한 접근 권한을 가진다. 그런데 이 때, 사용자 모드에서 프로세스가 디스크 읽기와 같은 특권 명령어를 실행하고자 하면 어떻게 해야 할까? 이런 작업을 허용하기 위해 프로세스에게 **시스템 콜(system call)** 을 제공한다.

시스템 콜을 실행하려면 프로그램은 trap 특수 명령어를 실행해야 한다. trap은 커널 안으로 분기하는 동시에 사용자 모드에서 커널 모드로 상향 조정한다. 운영체제는 요청 작업을 처리하면 return-from-trap 명령어를 호출해 다시 사용자 모드로 전환한다.

trap 명령어를 실행할 때 우리가 컨텍스트 스위칭을 하는 것처럼 기존에 실행되던 프로그램의 레지스터 값들을 저장해야 한다. return-from-trap 명령어를 실행 후 기존 프로세스로 제대로 돌아가기 위해서다. 그래서 몇 개의 레지스터를 각 프로세스의 **커널 스택(kernel stack)** 에 저장한다.

또한 trap 명령어가 운영체제 코드의 어느 부분을 실행할 지도 중요한 문제다. 프로세서가 분기할 주소를 알 수 없다. 따라서 커널은 컴퓨터 부팅 시에 **트랩 테이블(trap table)** 을 만들고 이를 이용하여 시스템을 통제한다. 이 때 하드웨어에게 시스템 콜 및 인터럽트가 발생했을 때 어떤 코드를 실행해야 할 지 알려준다. 즉 하드웨어에게 **트랩 핸들러(trap handler)** 의 위치를 알려준다.

### 프로세스 간 전환

CPU에서 프로세스를 직접 실행한다면, 즉 CPU에 대한 제어권을 프로세스가 계속 가지고 있다면 운영체제는 어떻게 프로세스를 멈추고 다른 프로세스를 실행할 수 있을까? 운영체제 코드를 실행하고 있지 않다면 운영체제는 어떠한 조치도 취할 수 없다. 

(예전 운체 수업을 들을 때 제대로 이해를 못했는데, 운영체제 자체도 프로그램이라 메모리의 커널 영역에 적재되어 있다는 사실을 알고 나니 이해가 된다..)

이 문제를 해결하기 위해서는 협조 방식과 비협조 방식이 있다. 

**협조(cooperative) 방식**은 과거 몇몇 시스템에서 채택된 방식으로 운영체제는 프로세스들이 합리적으로 행동할 것이라 기대하고 프로세스가 자주 시스템 콜을 호출하여 CPU에 대한 제어권을 운영체제로 넘겨줄 것이라 생각한다. 혹은 어떤 수를 0으로 나누는 연산 같은 불법적인 연산이 일어나길 기다린다.

**비협조 방식**은 **타이머 인터럽트(timer interrupt)** 를 이용하는 것이다. 특정 주기마다 인터럽트가 발생하면 수행 중인 프로세스가 중단되고 **인터럽트 핸들러(interrupt handler)** 가 실행된다. 이 시점에 운영체제는 CPU 제어권을 다시 획득할 수 있다. 앞서 시스템 콜과 마찬가지로 인터럽트 핸들러가 발생했을 때 하드웨어에게 실행해야 할 코드를 알려주어야 한다. 똑같이 부팅 중에 이런 준비를 한다.

어떤 방식이든 간에 프로세스가 전환될 때 어떤 프로세스가 실행될 지는 **스케줄러**에 의해 결정된다. 이런 프로세스 전환을 컨텍스트 스위치(context switch)라고 부르며 현재 실행 중인 프로세스의 레지스터 값을 커널 스택에 저장하고 곧 실행될 프로세스의 커널 스택으로부터 레지스터 값을 복원해야 한다.

ex) A → B의 context switch

1. 타이머 인터럽트 발생 후 A의 레지스터 값을 A의 커널 스택에 저장하고 커널 모드로 전환
2. 운영체제는 switch() 루틴을 호출하고 A의 레지스터 값을 A의 PCB에 저장한다.
3. B의 PCB로부터 B의 레지스터 값을 복원하고 커널 스택포인터를 B의 커널 스택으로 둔다.
4. return-from-trap을 수행하고 B의 커널 스택으로부터 B의 레지스터 값을 복원한다.

**여기서 커널 스택은 트랩 복귀용이고 PCB는 컨텍스트 스위치를 위한 영속 백업이라고 생각하면 된다.**

## 7. Scheduling

컨텍스트 스위칭이 발생할 때 어떤 프로세스를 실행해야 할 지는 스케줄러의 스케줄링 정책에 따라 결정된다. 다양한 스케줄링 정책을 비교해보자. 스케줄링 정책을 비교할 때는 **반환 시간(turnaround time = 작업 완료 시각 - 작업 시스템 도착 시각)** 과 **공정성(fairness)** 를 지표로 사용하는데 이 둘은 trade-off 관계에 있다. 비교를 위해 비현실적인 가정 5가지를 하고 하나씩 가정을 해제(?) 해보자.

1. 모든 작업은 같은 시간 동안 실행된다.
2. 모든 작업은 동시에 도착한다.
3. 각 작업은 시작되면 완료될 때까지 실행된다.
4. 모든 작업은 CPU만 사용한다.
5. 각 작업의 실행 시간은 사전에 알려져 있다.

### 선입선출(First In First Out, FIFO)

이름 그대로 먼저 도착한 작업을 먼저 실행한다. 이 문제는 자원을 오랫동안 사용하는 프로세스 때문에 작업이 늦어지는 현상인 **convoy effect**가 발생할 수 있다.

![image](https://github.com/user-attachments/assets/fb06bcdf-87ee-49cc-8131-0fd7c8559eb0)

FIFO 방식의 평균 반환 시간은 110초이다. (100+110+120)/3

(전부 0초에 도착했다고 가정했다)

### 최단 작업 우선 (Shortest Job First, SJF)

![image](https://github.com/user-attachments/assets/b1b33b70-d320-47e7-8d6d-ce721e5a437d)

작업 시간이 10초인 B와 C를 먼저 실행하면서 평균 반환 시간을 50초로 줄였다. 모든 작업이 동시에 도착한다면 SJF는 최적의 스케줄링 알고리즘일 것이다. 그러나 현실은 그렇지 않다.

![image](https://github.com/user-attachments/assets/0b85a911-a4da-49f0-b4a8-7a88ba8a29a5)

위와 같은 상황에선 대충 평균 반환 시간이 103초 정도 나오게 되며 convoy effect가 다시 발생한다.

### 최단 잔여시간 우선 (Shortest Time-to-Completion First, STCF or PSJF)

SJF 방식은 비선점 스케줄링 방식으로 B와 C가 도착했을 때 A의 작업을 중단할 수 없다. 반면 STCF는 선점형 스케줄링 방식으로 작업 중지가 가능하다.

![image](https://github.com/user-attachments/assets/6b764830-4b73-4496-b8db-0ce9403b313a)

평균 반환 시간이 50초가 된다.

### 응답 시간

**응답 시간**(response time)이라는 새로운 평가 기준을 도입하자. 응답 시간은 작업이 도착할 때부터 처음 스케줄 될 때 까지의 시간이다. 위의 STCF 예에서 평균 반환 시간은 짧을 수 있지만 응답 시간은 그렇지 않다. 다른 작업 때문에 내 작업에 대한 시스템 응답이 10초씩 걸릴 수도 있다. 그럼 응답 시간이 빠른 방식은 뭘까?

### 라운드 로빈 (Round-Robin, RR)

이전 정책들과는 달리 RR은 작업이 끝날 때까지 기다리지 않는다. 일정 시간인 **타임 슬라이스(time slice**)를 기반으로 작업들이 번갈아가며 실행된다. 여기서 고려해야 할 점은 타임 슬라이스의 길이는 **타이머 인터럽트 주기의 배수**여야 한다는 것이다.

![image](https://github.com/user-attachments/assets/5e35143d-0795-4760-b864-d49080f63b53)

타임 슬라이스 때문에 응답 시간이 SJF에 비해 월등히 좋아진다. 그렇다고 타임 슬라이스 길이를 매우 짧게 만들면 컨텍스트 스위칭이 매우 빈번하게 발생해 성능에 큰 영향을 끼친다. 그러나 반환 시간을 생각해보면 RR은 매우 안 좋은 정책이다.일반적으로 공정성을 고려한 정책들은 반환 시간이 느릴 수 밖에 없다.

### 입출력을 고려한 스케줄링

![image](https://github.com/user-attachments/assets/3f3d80d2-3839-4c3d-b0f3-12a1b6f57480)

![image](https://github.com/user-attachments/assets/4e2b5e98-c91d-46b7-a4a0-d51f0a43a49e)

프로세스가 입출력 I/O를 처리할 때는 프로세스가 대기 상태로 접어든다. 이 때 CPU가 아무것도 하지 않으면 굉장히 비효율적이기 때문에 왼쪽보단 오른쪽처럼 CPU가 노는 시간에 다른 프로세스를 실행하게 만든다.

여기까지 왔으면 5가지 가정 중 마지막 가정인 실행 시간을 알고 있다는 가정을 제외하면 전부 해결했다. 사실 마지막 가정은 우리가 알 수 있는 방법이 없다. 그래도 지금까지 각 문제를 해결한 노하우들이 잘 합쳐진 스케줄링 방식이 있다.

## 8. Multi-level Feedback Queue

### MLFQ

반환 시간과 응답 시간을 최적화 하기 위해 등장한 스케줄링 기법이다. 실행 중인 작업의 특성일 파악해 더 나은 스케줄링 결정을 돕는다.

MLFQ는 각각 다른 우선순위를 가지는 우선순위 큐가 존재한다. 그런데 각 작업에 고정된 우선순위를 부여하는 것이 아니라 작업의 정보를 통해 우선순위를 조정한다. MLFQ의 기본 규칙은 다음과 같다.

- 규칙 1 : 우선순위가 A > B 라면, A가 실행된다.
- 규칙 2 : 우선순위가 A = B 라면, A와 B는 RR 방식으로 실행된다.

![image](https://github.com/user-attachments/assets/7830a032-8fe3-41f5-96a7-d49692da7365)

만약 위의 상황이라면 A와 B가 RR 방식으로 실행되면서 C와 D는 실행되지도 않는다. 이를 해결하기 위해 새로운 규칙을 둔다.

- 규칙 3 : 작업이 시스템에 진입하면, 가장 높은 우선순위 큐에 배치한다.
- 규칙 4a : 주어진 타임 슬라이스를 모두 사용하면 우선순위가 낮아진다.
- 규칙 4b : 타임 슬라이스를 소진하기 전에 CPU를 양도하면 우선순위를 유지한다.

이 규칙들을 기반으로 우선순위 변화를 파악해보자.

![image](https://github.com/user-attachments/assets/34237709-2451-441d-b31e-1d67dbaaee3e)

이렇게 처음에는 최고 우선순위 큐로 진입하고 각 큐에서 타임 슬라이스를 전부 소진하면 우선순위가 낮아지게 된다.

![image](https://github.com/user-attachments/assets/8481e999-3b58-4586-92e7-e4224630bfd4)

그런데 이렇게 B(회색)은 대화형 작업으로서 1msec 동안만 CPU를 사용하고 양도한다. B는 우선순위가 유지되며 B가 양도한 CPU를 A(검정색)가 사용한다. 그런데 이 방식에는 문제가 있다.

1. **기아(Starvation)** 문제가 발생한다.  
    
    대화형 작업이 너무 많이 존재하면 그들이 CPU를 전부 소모하게 되어 CPU Bound 작업은 실행조차 못한다.
    
![image](https://github.com/user-attachments/assets/fdf4ec93-80ab-418e-9bdd-4aa3e8462e8f)


1. 작업이 타임 슬라이스의 99%를 실행하고 종료되기 직전에 CPU를 양도할 수 있다. 이렇게 되면 CPU를 거의 독점하게 된다. 이런 악의적인 의도를 막아야 한다.
2. CPU 위주의 작업이 대화형 작업으로 바뀌어도 우선순위가 이미 낮은 큐에 있어 실행이 안 된다.

이를 해결하기 위해 우리는 모든 작업의 우선순위를 상향 조정하게 된다. 전부 최상위 큐로 보내는 것이다.

- 규칙 5 : 일정 기간 S가 지나면, 모든 작업을 최상위 큐로 이동시킨다.

이 규칙은 2가지 문제(1, 3)를 전부 해결한다. 실행되지 않던 작업이 최상위 큐로 이동하면 결국 실행 할 수 있게 되기 때문이다. 물론 S 값의 결정이 필요하다.

그러나 2번 문제는 해결하지 못했는데 이를 해결하기 위해 규칙 4a, 4b를 조정하자.

- 규칙 4 : 주어진 단계에서 시간 할당량을 소진하면 우선순위는 낮아진다.

즉 CPU 총 사용 시간을 저장해 이 값이 타임 슬라이스를 초과하면 무조건 우선순위가 낮아지게 된다. 

![image](https://github.com/user-attachments/assets/f7ced371-053f-47cb-b6db-ce6a128bb34b)

위와 같이 타임 슬라이스가 끝나기 전에 CPU를 양도해도 총 사용 시간에 근거하여 우선순위를 낮춘다.

### MLFQ 조정

몇 개의 큐가 존재해야 하는가? 큐당 타임 슬라이스 크기는? 우선순위 조정의 S 값은? 이런 질문들에 대해 계속 조정해 나가면서 균형점을 찾아야 한다. 보통은 우선순위가 높을 수록 타임 슬라이스 값을 작게 만든다. 대부분 대화형 작업으로 이 작업들을 빠르게 교체하는 것은 의미가 있다.

### MLFQ 요약

- 규칙 1 : 우선순위가 A > B 인 경우, A가 실행된다.
- 규칙 2 : 우선순위가 A = B 인 경우, RR 방식으로 실행된다.
- 규칙 3 : 작업이 시스템에 들어가면 최상위 큐에 배치된다.
- 규칙 4 : CPU 사용 시간이 큐의 타임 슬라이스를 초과하면 우선순위가 낮아진다.
- 규칙 5 : 일정 주기 S마다 시스템의 모든 작업을 최상위 큐로 이동시킨다.

MLFQ는 반환 시간과 응답 시간이 모두 최적화되어 있어서 많은 OS에서 기본 스케줄러로 사용한다.
