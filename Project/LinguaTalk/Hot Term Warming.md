채팅이 발생할 때마다 현장 용어에 대한 조회는 지속적으로 발생한다.

현장 용어 조회에 대한 성능 개선은 어떻게 할 수 있을까?

Cache를 사용하는 방법을 먼저 떠올릴 수 있다. **그러나 모든 현장 용어를 Cache에 저장해도 될까?**

(현장 용어 개수 x 근로자의 사용 언어 개수) 만큼 저장해야 하기 때문에 모든 데이터를 저장 해둘 수는 없다.

그래서 **자주 사용되는 현장 용어인 Hot Term을 정의해 주기적으로 Cache에 Warming**하고자 한다.

(채팅방 데이터들은 계속 변경되기 때문에 Cache에 먼저 쓰고 DB에 동기화를 하는 방식으로 처리했지만 현장 용어는 변경되지 않고 잦은 조회가 이루어지기 때문에 반대로 Cache Warming으로 처리했다.)

현장 용어는 기본적으로 번역 API를 거쳐 DB에 저장되는데 여기서 다루진 않을 예정이다.

![image](https://github.com/user-attachments/assets/1485a816-3d66-4fc8-8f0f-993aad28b08a)

기본적으로 Hot Term 계산을 위해 생각한 Flow는 다음과 같다. 

1. 채팅이 발생하면 채팅 속의 현장 용어들을 아호코라식 알고리즘으로 추출한다.
2. 채팅 속의 현장 용어들에 대해 누적 조회수를 Local Cache에 저장한다.
3. Scheduler를 통해 주기적으로 Local Cache에 저장해둔 누적 조회수를 Redis에 저장한다.
4. Redis에 저장했다는 이벤트를 이용해 서버에서 데이터를 가져와 Hot Term을 계산한다.
5. Hot Term을 Local Cache에 저장해 사용자의 요청 시 반환 해준다.

여기서 고려했던 부분들을 정리해보자.

### 1. 현장 용어 누적 조회수를 Local Cache에 저장하는 이유

데이터를 임시로 저장해야 하는데 DB에 저장하기에는 너무 비효율적이고 성능을 고려해 굳이 Redis를 쓸 이유도 없다. 성능 자체도 Local Cache가 더 빠르다.

### 2. Hot Term을 어떻게 정의할 수 있을까?

[대용량 트래픽 아니면 안 보셔도 됩니다! 선물하기 서비스 캐싱 전략 if(kakaoAI)2024](https://www.youtube.com/watch?v=BUV4A2F9i7w&t=618s)

Cache Stampede 현상을 방지하기 위한 PER 알고리즘을 찾아보다가 카카오톡의 캐싱 전략 영상을 본 적이 있어 이 영상을 참고했다.

카카오 서버 개발 팀은 “Hot Promotion”을 정의하기 위해 페이지의 **“최근 호출 시각”과 “누적 호출 횟수”** 를 Redis에 저장해서 사용했다. 그리고 최근 호출 시각과 누적 호출 횟수에 적절한 가중치를 곱해 최종 Score를 계산해서 Hot Promotion을 선정했다.

이 아이디어를 참고해서 로직을 생각했다. **우선 Hot Term이란 뭘까?** 

**최근에 조회 될수록 그리고 더 많이 조회될수록 Hot Term에 가까울 것이다**.

원래는 “최근 호출 시각”과 “누적 호출 횟수”를 둘다 고려하려고 했으나, 두 값의 가중치 비율 계산을 어느 정도로 해야 될 지 정하는 부분이 상당히 어려워 일단 **누적 호출 횟수만 고려**했다.

그리고 누적 호출 횟수 자체도 1시간 단위로 나누어 저장되어 있다. 따라서 **현재 시각으로부터 가까운 누적 호출 횟수에는 큰 가중치를 두고 반대로 멀어질수록 작은 가중치를 두면 최근 호출 시각을 고려하지 않더라도 Hot Term을 정의하는데 큰 문제가 없을 것이라 판단**했다.

```java
Score = 0시간 전 가중치 x 0시간 전 누적 횟수 + 1시간 전 가중치 x 1시간 전 누적 횟수 ...
```

최종 점수는 위와 같이 정의했고 **가중치는 a^r (a는 임의의 값, r은 r시간 전)** 로 결정했다.

여기서 지수 가중치로 정한 이유는 시간이 지날 수록 점수 반영 비율이 크게 감소해야 하기 때문이다.

![image](https://github.com/user-attachments/assets/59de7cd3-d1ce-4747-9788-0397b7d0ff23)

그래서 a값과 r값에 따른 가중치 값을 계산해보았다.

a값을 0.9로 두었을 때 0시간 전과 23시간 전의 가중치 값이 1x배 정도 차이였으나 a값이 0.8인 순간부터 200배 이상 차이가 벌어지기 시작해 너무 과하다는 판단을 했다. 그래서 a 값은 0.9로 결정했다.

### 3. Hot Term 계산 시 필요한 데이터 범주

우선 24시간 내의 누적 조회수 값으로만 계산을 진행했고 TTL이나 Warming 주기도 24시간으로 맞추었다. 24시간의 근거는, **서비스의 성격**에서 찾았다. 이 서비스는 근로자들의 노동 시간 동안 주로 사용될 서비스다. Warming 주기를 너무 짧게 잡으면 다음 날 출근했을 때 Hot Term 계산이 힘들어지고 24시간으로 잡으면 전날 기록을 기반으로 Hot Term을 계산할 수가 있게 된다. 물론 더 길게 누적해서 저장하면 좋겠지만 무한히 누적할 순 없다. 또한 이렇게 Score를 계산 후 상위 100개의 Hot Term만 추가로 선정해 저장했다.

### 4. 누적 조회수를 Redis에 저장하는 이유

Redis는 다양한 자료구조를 제공한다. 누적 호출 횟수는 1시간 단위로 저장이 되어야 한다. Redis의 Hash 자료구조를 이용해 호출 시각을 Key로 잡고 1시간 단위로 저장하게 되면 쉽게 데이터 저장이 가능하다. 또한 Hot Term을 Server에서 계산하기 위해 Pub/Sub 구조를 활용하여 쉽게 Hot Term 계산 타이밍을 알려줄 수도 있다.

### 5. Hot Term을 Local Cache에 저장하는 이유

1번과 비슷한 이유도 있지만 지금은 **단일 서버 환경**에서 서비스가 구동 된다. 만약 서버가 여러 대로 확장된다면 Remote Cache인 Redis를 사용하는 것이 데이터 정합성의 측면에서 나을 수도 있지만 **현장 용어는 다른 데이터와 다르게 변경되지 않는다는 특징**이 있다. 따라서 확장성을 고려해도 데이터 정합성이 큰 문제가 되진 않는다. 각 Server의 Local Cache에 중복 저장되는 문제는 외부 메시지 브로커를 사용해 서버 별 Topic을 설정해 중복되지 않게 저장할 수 있다.
