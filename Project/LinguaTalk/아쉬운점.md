이번 LinguaTalk 프로젝트를 진행하며 실시간 채팅 서비스 개발 역할을 맡았다. 

다양한 Cache 전략을 데이터의 특성에 맞게 적용해보고 비동기 처리와 관련하여 발생할 수 있는 문제들을 대응해보는 경험을 할 수 있었다.

그러나 프로젝트의 여건 상 혹은 이미 종료된 프로젝트이기 때문에 시도해볼 수 없었던 부분들이 있어서 정리해본다.

## 1. 채팅 : 메시지 브로커

기본적으로 단일 서버 환경에서 개발을 진행했기 때문에 Spring에서 제공하는 내장 메시지 브로커인 SimpleBroker를 사용해서 채팅 서비스를 개발했다. 그런데 내장 브로커의 문제점들이 있다.

- 서버가 다운되면 메시지 큐의 데이터 유실
- 다중 서버 환경에서 서버 간의 채팅방 공유 X
- STOMP의 일부 명령어를 사용 X

그렇지만 실제 운영 서비스가 아니기도 하고 기본적으로 단일 인스턴스 환경이라 내장 브로커로도 구현 자체에는 큰 문제가 없었다.

3번에서 얘기하겠지만 개발을 하다 보니 각 기능을 담당하는 서버를 따로 두면 좋을 것 같다는 생각을 하게 되었다. 그렇게 되면 채팅 서버도 여러 개를 두고 외부 메시지 브로커를 사용하면 위의 단점을 해소할 수 있겠지..  추후 채팅 서비스 개발에선 외부 메시지 브로커를 사용해보자.

## 2. NoSQL

사실 채팅방 기능을 개발하면서 외부 레퍼런스를 참고하진 않았다. 그리고 NoSQL은 Redis만 캐시 정도로 써봤기 때문에 당연히 RDB를 써야지 라는 생각을 하고 있었는데 개발이 거의 완성된 이후 새로운 정보를 알게 되었다.

채팅 데이터도 User나 Team과 연관 관계를 맺어야 하기 때문에 RDB에 저장하는 것이 이상하다는 생각을 하진 않았다. 그러나 채팅 데이터의 특징은 다음과 같다.

- 채팅 데이터 양은 매우 많다. 페이스북 메신저는 매일 약 600억개의 메시지를 처리한다.
- 가장 빈번하게 조회 되는 데이터는 최근에 주고 받은 메시지다. 대부분 오래된 메시지를 확인하지 않는다.
- 검색 기능, 언급 기능, 특정 메시지 답장하기 기능 등 무작위 데이터 접근이 필요한 경우에는 해당 기능을 제공해야 한다.
- 1:1 채팅에선 읽기:쓰기 비율이 1:1 정도로 발생한다.

**그래서 보통은 채팅 데이터만 NoSQL에 저장하고 나머지 데이터는 RDB에 저장하는 선택을 한다고 한다.**

또한 이번에는 DB 서버를 1개만 두어 모든 메시지를 비롯한 모든 채팅 관련 데이터를 하나의 서버에 저장했는데 트래픽이 많이 발생하면 물리적 한계로 인해 성능이 느려질 수 밖에 없다.

DB를 스케일 업 할수도 있지만 스케일 업은 언제나 한계가 있기에 스케일 아웃 방안을 고려해야 하는데, 특히 당근에서는 채팅 서버를 개발할 때 **샤딩**을 통해 이를 해결할 수 있었다고 한다.

당근에선 DynamoDB를 사용했는데 샤드 키를 지정하면 자동으로 샤딩이 된다고 한다.

[당근 채팅 서버 개발](https://www.youtube.com/watch?v=_F6k0tg8ODo)

이번 프로젝트에서는 이런 정보들을 늦게 알게 되어 DB를 바꾸진 못했지만 추후 기회가 된다면 적용해봐야겠다.

## 3. 비동기 처리 : 메시지 브로커

비동기 처리를 하거나 Hot Term 계산 같은 로직을 구성하면서 느낀 점은, 단일 서버에서 너무 많은 처리가 이루어진다는 것이다. 서버가 1개니까 결국 빙글빙글 돌아 이 서버로 요청이 전달될 수 밖에 없다.

실제 트래픽이 발생해 문제가 생겼던 것은 아니지만 각 기능을 담당하는 여러 서버를 두면 좋을 것 같다는 생각을 하게 되었다. 

특히 번역 API 호출이 한 번에 몰리는 경우 (채팅이 순간적으로 많이 발생하는 경우) 에 **플랫폼 스레드 개수 급증 문제**를 해결하는 방법을 찾고 있었다.

이 때 **외부 메시지 브로커를 써서 외부 서버인 worker에서 특정 이벤트(번역 API)를 받아 처리한다면** 스레드를 만들지 않으면서 문제를 해결할 수가 있었다.

그러나 당장 단일 인스턴스 환경인 상황 + 프로젝트 끝난 상황에 내가 서버를 늘려 볼 수는 없는 상황이었다.

물론 **Virtual Thread**를 사용해 문제를 해결 할 수는 있었지만 분산 서버 환경을 도입해보면 좋을 것 같다. 

## 4. Redis

이번 프로젝트에서 가장 심혈을 기울인 부분이 Cache 처리였다. 

이 때 Redis를 사용했는데 Redis와 관련한 다양한 자료구조를 공부할 수 있었고 싱글 스레드로 동작하기 때문에 O(n) 명령어를 조심해야 한다거나 pub/sub 구조를 써보기도 하고 DB 동기화 방법도 많이 공부 할 수 있었다.

그러나 Redis의 아키텍처와 관련한 부분은 거의 건들지 못했다.. 지금은 Redis 인스턴스가 1개인 싱글 노드 아키텍처를 쓰고 있는데 이러면 장애 발생 시(failover) 복구 문제에 대비가 안 된다.

Master/Replica나 Redis Sentinel, Cluster 같은 구성도 추가로 공부해봐야 할 듯하다.

또한 Hot Term을 계산하면서 Redis의 Pub/Sub을 활용하였는데 메시지 브로커 중 Redis는 메시지 유실 가능성이 가장 큰 서비스라고 한다.

이에 대한 방안을 마련하지 못했고 Kafka나 RabbitMQ를 도입하는 방안도 좋을 듯 하다.

## 5. 채팅 즉시 읽음 처리

실시간 채팅에서 상대방의 채팅을 즉시 읽었다는 표시를 보여주고 싶었는데 이 또한 개발하지 못헀다. 사실 이건 몰라서 개발 못했다고 하는 것이 맞을 것 같다.

위의 당근 유튜브에서 이에 대한 소개도 잠깐 나오는데 아키텍처 구조가 상당히 복잡하다..

## 6. 채팅 푸시 알림

다른 채팅 시스템은 미로그인 상태의 유저에게 채팅 푸시 알림을 전송해준다. 단순하게 안 읽은 메시지 개수를 보여주기만 했지 이를 개발하진 못했다.
