## WebSocket

- WebSocket은 웹 애플리케이션에서 양방향 통신을 가능하게 하는 프로토콜이다.
- 단일 TCP 연결을 통해 **Full-Duplex** 통신 채널을 제공한다.
    - **HTTP Hand-Shake** 이후 Socket 연결을 유지하며 통신한다.
- HTTP/HTTPS와 동일하게 80, 443 port를 사용하기 때문에 방화벽이 있는 환경에서도 잘 동작한다.

## HTTP 프로토콜과의 차이

- HTTP는 클라이언트의 요청이 발생해야 응답을 전송할 수 있는 **Half-Duplex** 통신이다.
- 비연결성 통신이자 Stateless 통신이다.

- 반면에 WebSocket은 클라이언트의 연결 설정 이후에는 양쪽에서 요청을 실시간으로 보낼 수 있다.
- 한 번 연결되면, 한 쪽에서 명시적으로 닫을 때까지 유지된다.
- 둘다 애플리케이션 계층의 프로토콜이다.

## 실시간 통신

우리가 HTTP 프로토콜을 이용해 실시간 통신을 할 수 있을까? 물론 아예 불가능한 것은 아닌데 방법들을 살펴보자.

### Polling

- 브라우저가 일정 주기마다 서버에 HTTP 요청을 보낸다. 주기가 짧을 수록 실시간성은 높아지지만 서버의 부하가 증가하는 Trade-Off가 있다.

### Long Polling

- Polling 방식의 서버 부하를 줄이면서 실시간성을 높이기 위한 방식이다. 기존의 Polling 방식과는 달리 클라이언트의 요청에 대한 응답을 서버 Event 발생 시점에 보낸다. 즉 서버 측에서 접속을 열어두는 시간을 길게 하는 방식이다.
- 좋은 방법처럼 보이지만 서버에 트래픽이 일시적으로 몰리는 경우가 발생할 수 있으며 많은 연결 유지에도 비용이 적지 않게 발생한다.

**→ 따라서 실시간 통신에는 WebSocket 프로토콜 사용이 적절하다.**

![image](https://github.com/user-attachments/assets/47b441b7-83af-4e5a-9c22-233dcd9a81da)

## Sub Protocol

- WebSocket은 데이터 전송 방법에 대한 정의일 뿐, 보내지는 데이터의 형식이나 구조에 대한 내용을 명시하지 않는다. 결국 메시지에 대한 내용은 애플리케이션 레벨에서 처리해야 하며 클라이언트 간의 별도 협의가 필요하다. 이를 명시한 것이 바로 **하위 프로토콜(Sub Protocol)**이다.

결국 하위 프로토콜을 사용해야 하는 이유를 정리하면 아래와 같다.

- 일관된 메시지 구조와 형식 정의
- 메시지 라우팅
- 연결 관리 간소화
- 오류 처리

사실 가장 큰 이유는 1, 2 인 것 같다. 

## STOMP (Simple Text Oriented Messaging Protocol)

- 간단한 텍스트 기반의 메시징을 정의한 프로토콜이다.
- 텍스트 기반이고 메시지가 명확한 구조를 가지고 있기 때문에 사람이 읽기 쉽고 사용이 간단하며 다양한 언어와 플랫폼에서 지원한다.
- **Pub-Sub** 메시징 방법을 지원한다.
    - 클라이언트는 메시지를 받고 싶은 topic을 구독(subscribe)하고, 특정 topic에 메시지를 전달(publish)한다.
    - 특정 topic에 메시지가 pub되면 **Message Broker**가 해당 topic을 구독한 클라이언트를 확인하고 STOMP 형식으로 메시지를 전달하기 때문에 서버가 WebSocket Session을 관리하며 라우팅 해주지 않아도 된다.

## Message Broker

우선 STOMP는 **메시지 지향 미들웨어(MOM)**을 위한 프로토콜이다. Message Broker는 MOM의 핵심 구성 요소 중 하나이며 다음과 같은 역할을 수행한다.

- 메시지 수신 및 저장
- 메시지 라우팅
- 구독자에게 메시지 전달
- 필요 시 메시지 변환
- 신뢰성 있는 메시지 전달

이 때, STOMP는 서버의 내장 메시지 브로커를 사용하거나 외부 메시지 브로커와 연동할 수 있다.

우리가 Spring Framework에서 STOMP를 사용하게 되면 Spring에서 제공하는 **SimpleBroker**를 사용할 수 있다. 그러나 내장 인메모리 기반 브로커를 사용하면 문제가 발생할 수 있다.

- 서버가 다운되면 메시지 큐에 있는 데이터가 유실될 수 있다.
- 다중 서버 환경에서 서버 간에 채팅방을 공유할 수 없다.
- 또한 Spring 공식 문서에서도 STOMP의 일부 명령어를 사용하지 못하며 클러스터링 환경에서 불리하다고 한다.

![image](https://github.com/user-attachments/assets/de3f7c2c-813d-498c-a0ff-020264551ee9)


위와 같은 문제를 해결하기 위해서는 **외부 메시지 브로커인 Redis, Kafka, RabbitMQ** 등을 사용하는 것이 좋다.

![image](https://github.com/user-attachments/assets/3abb42a8-66c4-4b26-8d9c-f843cfea7768)
